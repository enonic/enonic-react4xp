/* eslint-disable no-console */

/*
  Externals is webpack's way to keep certain dependencies
  out of the compilation/chunking flow,
  and instead tell compiled code that they will be
  globally available in runtime from other Ã­mported libraries, say from a CDN.

  This webpack file wraps the building those external libraries from existing packages.
  They are built into one separate chunk (TODO for later: multiple chunks?),
  along with some features tailored for React4xp:
  it gives the produced chunk a contenthash in the filename, and outputs a JSON file with the
  hashed name, for runtime reference. Content-hashed for caching and cache-busting.

  Which dependencies are inserted into the external library,
  depends on an `env.EXTERNALS` parameter (EXTERNALS can also be supplied through a
  JSON config file referenced with an `env.REACT4XP_CONFIG_FILE` - see for example
  [react4xp-buildconstants](https://www.npmjs.com/package/react4xp-buildconstants), although you can roll your own).
  This `EXTERNALS` parameter must be an object on the webpack
  externals format `{ "libraryname": "ReferenceInCode", ... }`,
  e.g. `{ "react-dom": "ReactDOM" }`. These libraries of course have to be supplied
  from the calling context (as such, they can be thought of
  as peer dependencies, but are obviously impossible to declare).
  `EXTERNALS` can also be a valid JSON-format string.

  In the same way, one more parameter is expected either directly through `env`
  or in the JSON file referenced through `env.REACT4XP_CONFIG_FILE`:
  - `BUILD_R4X`: mandatory string, full path to the
  React4xp build folder (where all react4xp-specific output files will be built)
*/

const {
  statSync,
  writeFileSync
} = require('fs');

const {
  isAbsolute,
  join,
  resolve
} = require('path');

const Chunks2json = require("chunks-2-json-webpack-plugin");
const FileManagerPlugin = require('filemanager-webpack-plugin');

const {
  EXTERNALS_CHUNKS_FILENAME
} = require('../dist/constants.runtime');
const {
  DIR_PATH_RELATIVE_BUILD_ASSETS_R4X,
  EXTERNALS_DEFAULT,
  FILE_NAME_R4X_CONFIG_JSON,
  FILE_NAME_R4X_PROPERTIES
} = require('../dist/constants.buildtime');
const {getProperties} = require("../dist/properties/getProperties");
const {isSet} = require("../dist/util/isSet");
const {
  cleanAnyDoublequotes,
  makeVerboseLogger
} = require("../util");

// TODO: Find a good pattern to control output name for chunks,
// allowing for multi-chunks and still doing it in one pass (only one chunks.externals.json)
// TODO: Allowing build path (where BUILD_R4X today must be absolute)
// to instead be relative to project/calling context

// First autogenerates an externals temporary sourcefile,
// and then lets webpack have its filename in order to transpile it. Returns null if somethings off.
function generateTempES6SourceAndGetFilename(_externals, outputFileName) {
  if (
    typeof outputFileName !== "string" ||
    (outputFileName || "").trim() === ""
  ) {
    console.warn(`${__filename} - Skipping generation of the externals chunk:
        \tThe outputFileName parameter must be a non-empty string: ${JSON.stringify(
          outputFileName,
          null,
          2
        )}`);
    return null;
  }

  let externals = _externals;

  if (typeof externals === "string") {
    externals = JSON.parse(_externals);
  }
  if (
    !externals ||
    typeof externals !== "object" ||
    Array.isArray(externals) ||
    Object.keys(externals) < 1
  ) {
    console.warn(`${__filename} - Skipping generation of the externals chunk:
        \tThe externals parameter must be an object (or JSON-string object) with at least one entry: ${JSON.stringify(
          externals,
          null,
          2
        )}`);
    return null;
  }

  let externalsImports = "";
  let externalsExports = "";

  Object.keys(externals).forEach((key) => {
    externalsImports += `import ${externals[key]} from '${key}';\n`;
  });

  Object.keys(externals).forEach((key) => {
    externalsExports += `\twindow.${externals[key]} = ${externals[key]};\n`;
  });

  const externalsES6 = `// AUTO-GENERATED by ${__filename}\n\n${externalsImports}\n(function(window) {\n${externalsExports}} )(typeof window !== 'undefined' ? window : global);\n`;

  writeFileSync(outputFileName, externalsES6);

  return outputFileName;
}

module.exports = (env = {}) => {
  const DIR_PATH_ABSOLUTE_PROJECT = cleanAnyDoublequotes("DIR_PATH_ABSOLUTE_PROJECT", env.DIR_PATH_ABSOLUTE_PROJECT || process.cwd());
  if (!isAbsolute(DIR_PATH_ABSOLUTE_PROJECT)) {
    throw new Error(`env.DIR_PATH_ABSOLUTE_PROJECT:${DIR_PATH_ABSOLUTE_PROJECT} not an absolute path!`);
  }

  const DIR_PATH_ABSOLUTE_BUILD_ASSETS_R4X = join(DIR_PATH_ABSOLUTE_PROJECT, DIR_PATH_RELATIVE_BUILD_ASSETS_R4X);

  let EXTERNALS = EXTERNALS_DEFAULT;
  //console.debug('EXTERNALS', EXTERNALS);
  const FILE_PATH_ABSOLUTE_R4X_CONFIG_JSON = join(DIR_PATH_ABSOLUTE_PROJECT, FILE_NAME_R4X_CONFIG_JSON);
  const configJsonStats = statSync(FILE_PATH_ABSOLUTE_R4X_CONFIG_JSON);
  if (configJsonStats.isFile()) {
    const config = require(FILE_PATH_ABSOLUTE_R4X_CONFIG_JSON);
    //console.debug('config', config);
    if (config.externals) {
      EXTERNALS = Object.assign(config.externals, EXTERNALS);
    }
  } // if FILE_NAME_R4X_CONFIG_JSON
  //console.debug('EXTERNALS', EXTERNALS);

  let {
    BUILD_ENV = 'production',
    VERBOSE = false
  } = env;
  //console.debug('BUILD_ENV', BUILD_ENV);
  //console.debug('VERBOSE', VERBOSE);

  const FILE_PATH_ABSOLUTE_R4X_PROPERTIES = join(DIR_PATH_ABSOLUTE_PROJECT, FILE_NAME_R4X_PROPERTIES);
  const r4xPropertiesStats = statSync(FILE_PATH_ABSOLUTE_R4X_PROPERTIES);
  if (r4xPropertiesStats.isFile()) {
    const properties = getProperties(FILE_PATH_ABSOLUTE_R4X_PROPERTIES);
    //console.debug('properties', properties);

    if (isSet(properties.buildEnv)) {
      BUILD_ENV = cleanAnyDoublequotes('buildEnv', properties.buildEnv);
    }

    if (isSet(properties.verbose)) {
      VERBOSE = cleanAnyDoublequotes('verbose', properties.verbose) !== 'false';
    }
  } // if FILE_NAME_R4X_PROPERTIES
  //console.debug('BUILD_ENV', BUILD_ENV);
  //console.debug('VERBOSE', VERBOSE);

  const verboseLog = makeVerboseLogger(VERBOSE);
  verboseLog(DIR_PATH_ABSOLUTE_BUILD_ASSETS_R4X, "DIR_PATH_ABSOLUTE_BUILD_ASSETS_R4X", 1);

  const tempFileName = generateTempES6SourceAndGetFilename(
    EXTERNALS,
    join(__dirname, "_AUTOGENERATED_tmp_externals_.es6")
  );

  const entry = tempFileName ? { externals: tempFileName } : {};

  const plugins = tempFileName
    ? [
        new FileManagerPlugin({
          events: {
            onStart: {
              mkdir: [
                DIR_PATH_ABSOLUTE_BUILD_ASSETS_R4X // Chunks2json fails without this (when using npm explore)
              ]
            }
          }
        }),
        new Chunks2json({
          outputDir: DIR_PATH_ABSOLUTE_BUILD_ASSETS_R4X,
          filename: EXTERNALS_CHUNKS_FILENAME,
        }),
      ]
    : undefined;

  return {
    devtool: BUILD_ENV === "production" ? undefined : "source-map",

    entry,

    mode: BUILD_ENV,

    module: {
      rules: [
        {
          test: /\.((jsx?)|(es6))$/,
          exclude: /node_modules/,
          use: {
            loader: "babel-loader",
            options: {
              compact: BUILD_ENV === "production",
            },
          },
        },
      ],
    }, // module

    output: {
      path: DIR_PATH_ABSOLUTE_BUILD_ASSETS_R4X, // <-- Sets the base url for plugins and other target dirs.
      filename: '[name].[contenthash].js',
      environment: {
        arrowFunction: false,
        bigIntLiteral: false,
        const: false,
        destructuring: false,
        dynamicImport: false,
        forOf: false,
        module: false,
      },
    }, // output

    plugins,

    resolve: {
      extensions: [".es6", ".js", ".jsx"],
      modules: [resolve(DIR_PATH_ABSOLUTE_PROJECT, 'node_modules')]
    }

  };
};
